__BRYTHON__.use_VFS = true;
var scripts = {"$timestamp": 1586890907973, "mercylog_datascript": [".py", "__version__='0.1.0'\n\nfrom .core import DataScriptV1\n", ["mercylog_datascript.core"], 1], "mercylog_datascript.core": [".py", "\n\n\n\nSPACE=' '\n\n\nclass Variable(object):\n\n def __init__(self,name):\n  self.name=name\n  \n def __str__(self):\n  return self.name\n  \n def code(self):\n  return \"?\"+self.name\n  \n  \nclass AggregateFunction(object):\n\n\n\n def __init__(self,name,args=None ):\n  self.name=name\n  self.args=args or tuple()\n  \n def __call__(self,*args,**kwargs):\n  self.args=args\n  return self\n  \n def code(self):\n  _code=spacify([self.name,self.args[0].code()])\n  return listify(_code)\n  \n  \n  \n  \n  \nclass UnderScoreVariable(object):\n\n\n def __init__(self):\n  self.name=\"_\"\n  \n def __str__(self):\n  return self.name\n  \n def code(self):\n  return str(self.name)\n  \n  \nclass DatabaseVariable(Variable):\n\n\n\n def __init__(self):\n  self.name=\"$\"\n  super(DatabaseVariable,self).__init__(self.name)\n  \n def __str__(self):\n  return self.name\n  \n def code(self):\n \n  return str(self.name)\n  \n  \nclass RuleVariable(Variable):\n\n\n\n def __init__(self):\n  self.name=\"%\"\n  super(RuleVariable,self).__init__(self.name)\n  \n def __str__(self):\n  return self.name\n  \n def code(self):\n \n  return str(self.name)\n  \n  \nclass AnyParameter(object):\n\n def __init__(self,variable):\n  self.variable=variable\n  \n def __str__(self):\n  return self.variable\n  \n def code(self):\n \n \n  return '['+self.variable.code()+' ...]'\n  \n  \nclass CollectionParameter(object):\n\n def __init__(self,variables):\n  self.variables=variables\n  pass\n  \n def __str__(self):\n  return self.variables\n  \n def code(self):\n  mapped_vars=map(lambda x:x.code(),self.variables)\n  return '[['+spacify(mapped_vars)+']]'\n  \n  \nclass Query(object):\n\n def __init__(self,find,where,parameters):\n  self.find=find\n  self.where=where\n  self.parameters=parameters\n  \n def code(self):\n  vars=self.to_code(self.find)\n  \n  spaced_vars=spacify(vars)\n  find_str=':find '+spaced_vars\n  \n  where_str_list=map(lambda a_l:translate_where(a_l),self.where)\n  where_str=spacify(where_str_list)\n  parameter_str=self.make_parameter_str(self.parameters,self.where)\n  \n  return f\"[{find_str} {parameter_str}:where {where_str}]\"\n  pass\n  \n def make_parameter_str(self,parameters,where):\n \n  all_parameters=[]\n  \n  if parameters or relation_in_where(where):\n   all_parameters.append(DatabaseVariable())\n   \n  if relation_in_where(where):\n   all_parameters.append(RuleVariable())\n   \n  if parameters:\n   all_parameters.extend(parameters)\n   \n  if all_parameters:\n   parameter_str=spacify([\":in\"]+list(self.to_code(all_parameters)))+SPACE\n  else :\n   parameter_str=''\n  return parameter_str\n  \n @staticmethod\n def to_code(var_list):\n  return findables_to_code(var_list)\n  \n  \ndef relation_in_where(where):\n is_rule=map(lambda x:isinstance(x,Relation),where)\n return any(is_rule)\n \n \ndef findables_to_code(var_list):\n\n result=[]\n for r in var_list:\n  if hasattr(r,'code'):\n   result.append(r.code())\n  elif isinstance(r,str):\n   result.append(f'\"{r}\"')\n  else :\n   result.append(str(r))\n return result\n \n \ndef spacify(code):\n return SPACE.join(code)\n \n \n \n \n \n \n \n \n \n \ndef codify(atom):\n if isinstance(atom,Variable)or isinstance(atom,UnderScoreVariable)or isinstance(atom,Relation):\n  return atom.code()\n elif isinstance(atom,str):\n  return f'\"{atom}\"'\n else :\n  return str(atom)\n  \n  \nclass RelationalFunction(object):\n def __init__(self,name,function=None ,variables=None ):\n  self.name=name\n  self.function=function\n  self.variables=list()\n  \n def __call__(self,*variables):\n \n  self.variables=list(variables)\n  return self\n  \n def __str__(self):\n \n  var_str=findables_to_code(self.variables)\n  _code=spacify([self.code(),spacify(var_str)])\n  r=listify(_code)\n  return r\n  \n def code(self):\n  if self.function:\n   return \"?\"+self.name\n  else :\n   return self.name\n   \n   \nclass Aggregate:\n def __init__(self):\n  pass\n  \n def __getattr__(self,name):\n  return AggregateFunction(name)\n  \n  \nclass DataScriptFunction:\n\n def __init__(self,var_name,function_name):\n  self.var_name=var_name\n  self.function_name=function_name\n  self.terms=tuple()\n  \n def __call__(self,*args,**kwargs):\n  self.terms=args\n  return self\n  pass\n  \n def str(self):\n  return self.code()\n  \n def code(self):\n \n  mapped_vars=[]\n  for t in self.terms:\n   if isinstance(t,Variable):\n    mapped_vars.append(t.code())\n   else :\n    mapped_vars.append(f'\"{t}\"')\n    \n  _code=spacify([self.function_name,self.var_name,spacify(mapped_vars)])\n  return listify(_code)\n  \n  \nclass Var:\n def __init__(self,name):\n  self.name=name\n  pass\n  \n def __getattr__(self,name):\n  return DataScriptFunction(self.code(),name)\n  \n def code(self):\n  return \"?\"+self.name\n  \n  \nclass InvertedRelationInstance(object):\n def __init__(self,relation_instance):\n  self.relation_instance=relation_instance\n  pass\n  \n def get_clause(self):\n  return \"not \"+self.relation_instance.get_clause()\n  \n def relation(self):\n  return self.get_clause()\n  \n def variables(self):\n  return self.relation_instance.variables()\n  \n  \nclass Facts(object):\n def __init__(self,*fact_list):\n  self.fact_list=fact_list\n  \n def get_clause(self):\n  fact_list_str=[f.relation()for f in self.fact_list]\n  return ', '.join(fact_list_str)\n  \n pass\n \n \nclass Fact(object):\n def __init__(self,terms):\n  self.terms=terms\n  \n  \nclass Rule(object):\n def __init__(self,head_atom,body_atoms):\n  self.head_atom=head_atom\n  self.body_atoms=body_atoms\n  pass\n  \n def relation(self):\n  if self.body_atoms:\n   mid_fragment=' :- '+str(self.body_atoms)\n  else :\n   mid_fragment=''\n   \n  result=self.head_atom.relation()+mid_fragment\n  return result\n  \n def get_clause(self):\n  if self.body_atoms:\n   mid_fragment=' :- '+self.body_atoms.get_clause()\n  else :\n   mid_fragment=''\n   \n  return self.head_atom.relation()+mid_fragment\n  \n  \nclass RelationInstance(object):\n def __init__(self,name,*variables):\n  self.name=name\n  self._variables=variables\n  \n def __le__(self,body):\n  if isinstance(body,list):\n   b=Facts(*body)\n  else :\n   b=body\n  return Rule(self,b)\n  \n def variables(self):\n  return self._variables\n  \n def get_clause(self):\n  return self.relation_x()\n  \n def relation_x(self):\n  var_strs=[]\n  \n  for v in self.variables():\n   if isinstance(v,str):\n    x=f'\"{v}\"'\n   else :\n    x=str(v)\n    \n   var_strs.append(x)\n  a_str=','.join(var_strs)\n  return self.name+listify(a_str)\n  \n def relation(self):\n  return self.relation_x()\n  \n def __invert__(self):\n  return InvertedRelationInstance(self)\n  pass\n  \n  \nclass Relation(object):\n def __init__(self,name):\n  self._name=name\n  self.terms=tuple()\n  \n def name(self):\n  return self._name\n  \n def __call__(self,*variables):\n  self.terms=variables\n  return self\n  \n def code(self):\n  mapped_vars=[]\n  for t in self.terms:\n   if isinstance(t,Variable):\n    mapped_vars.append(t.code())\n   else :\n    mapped_vars.append(f'\"{t}\"')\n    \n  _code=spacify([self.name(),spacify(mapped_vars)])\n  \n  return listify(_code)\n  \n  \n  \n  \n  \n  \nclass DataScriptV1(object):\n _=UnderScoreVariable()\n DB=DatabaseVariable()\n agg=Aggregate()\n RULE=RuleVariable()\n \n @staticmethod\n def function(name,func=None ):\n  return RelationalFunction(name=name,function=func)\n  \n @staticmethod\n def relation(name):\n  return Relation(name)\n  \n @staticmethod\n def rule(head,body):\n  return Rule(head,body)\n  \n @staticmethod\n def any(v):\n  return AnyParameter(v)\n  pass\n  \n @staticmethod\n def collection(vars):\n  return CollectionParameter(vars)\n  pass\n  \n @staticmethod\n def variables(*vars):\n \n  result=[Variable(v)for v in vars]\n  if len(result)==1:\n   return result[0]\n  else :\n   return result\n   \n def query(self,find,where,parameters=None ):\n  parameters=parameters or []\n  return Query(find=find,where=where,parameters=parameters)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \ndef translate_where(where_clause):\n if isinstance(where_clause,Relation):\n  result=where_clause.code()\n elif isinstance(where_clause,RelationalFunction):\n  result=where_clause.code()\n else :\n  result=map(codify,where_clause)\n  result='['+spacify(result)+']'\n  \n return result\n \n \ndef listify(code):\n return '('+code+')'\n", []]}
__BRYTHON__.update_VFS(scripts)
